// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.3
// source: basket.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { Timestamp } from './google/protobuf/timestamp';

export const protobufPackage = 'basket';

export interface Basket {
  basketId: string;
  contactDetails: Basket_ContactDetails | undefined;
  items: Basket_Item[];
  paymentDetails: Basket_PaymentDetails | undefined;
  totalCost: number;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  deletedAt: Date | undefined;
}

/** Contact details for the basket (user's information) */
export interface Basket_ContactDetails {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  address: Basket_Address | undefined;
}

/** Shipping or billing address details */
export interface Basket_Address {
  addressLine1: string;
  addressLine2: string;
  postalCode: string;
  city: string;
  state: string;
  country: string;
}

/** Represents an individual item in the basket */
export interface Basket_Item {
  /** Unique identifier for the item */
  itemId: string;
  /** Name of the item */
  name: string;
  /** Description of the item */
  description: string;
  /** Quantity of the item */
  quantity: number;
  /** Price per item */
  price: number;
}

/** Payment-related details (e.g., for credit card or other payment method) */
export interface Basket_PaymentDetails {
  /** Payment method (e.g., "credit_card", "paypal") */
  paymentMethod: string;
  /** Transaction ID if available (optional by default) */
  transactionId: string;
  /** Payment status (e.g., "pending", "completed") (optional by default) */
  status: string;
  /** Date of payment */
  paymentDate: Date | undefined;
}

function createBaseBasket(): Basket {
  return {
    basketId: '',
    contactDetails: undefined,
    items: [],
    paymentDetails: undefined,
    totalCost: 0,
    createdAt: undefined,
    updatedAt: undefined,
    deletedAt: undefined,
  };
}

export const Basket: MessageFns<Basket> = {
  encode(
    message: Basket,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.basketId !== '') {
      writer.uint32(10).string(message.basketId);
    }
    if (message.contactDetails !== undefined) {
      Basket_ContactDetails.encode(
        message.contactDetails,
        writer.uint32(18).fork(),
      ).join();
    }
    for (const v of message.items) {
      Basket_Item.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.paymentDetails !== undefined) {
      Basket_PaymentDetails.encode(
        message.paymentDetails,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.totalCost !== 0) {
      writer.uint32(41).double(message.totalCost);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createdAt),
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updatedAt),
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.deletedAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.deletedAt),
        writer.uint32(66).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Basket {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contactDetails = Basket_ContactDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(Basket_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentDetails = Basket_PaymentDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.totalCost = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deletedAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket {
    return {
      basketId: isSet(object.basketId)
        ? globalThis.String(object.basketId)
        : '',
      contactDetails: isSet(object.contactDetails)
        ? Basket_ContactDetails.fromJSON(object.contactDetails)
        : undefined,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => Basket_Item.fromJSON(e))
        : [],
      paymentDetails: isSet(object.paymentDetails)
        ? Basket_PaymentDetails.fromJSON(object.paymentDetails)
        : undefined,
      totalCost: isSet(object.totalCost)
        ? globalThis.Number(object.totalCost)
        : 0,
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : undefined,
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : undefined,
      deletedAt: isSet(object.deletedAt)
        ? fromJsonTimestamp(object.deletedAt)
        : undefined,
    };
  },

  toJSON(message: Basket): unknown {
    const obj: any = {};
    if (message.basketId !== '') {
      obj.basketId = message.basketId;
    }
    if (message.contactDetails !== undefined) {
      obj.contactDetails = Basket_ContactDetails.toJSON(message.contactDetails);
    }
    if (message.items?.length) {
      obj.items = message.items.map(e => Basket_Item.toJSON(e));
    }
    if (message.paymentDetails !== undefined) {
      obj.paymentDetails = Basket_PaymentDetails.toJSON(message.paymentDetails);
    }
    if (message.totalCost !== 0) {
      obj.totalCost = message.totalCost;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.deletedAt !== undefined) {
      obj.deletedAt = message.deletedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket>, I>>(base?: I): Basket {
    return Basket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket>, I>>(object: I): Basket {
    const message = createBaseBasket();
    message.basketId = object.basketId ?? '';
    message.contactDetails =
      object.contactDetails !== undefined && object.contactDetails !== null
        ? Basket_ContactDetails.fromPartial(object.contactDetails)
        : undefined;
    message.items = object.items?.map(e => Basket_Item.fromPartial(e)) || [];
    message.paymentDetails =
      object.paymentDetails !== undefined && object.paymentDetails !== null
        ? Basket_PaymentDetails.fromPartial(object.paymentDetails)
        : undefined;
    message.totalCost = object.totalCost ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.deletedAt = object.deletedAt ?? undefined;
    return message;
  },
};

function createBaseBasket_ContactDetails(): Basket_ContactDetails {
  return {
    firstName: '',
    lastName: '',
    email: '',
    phoneNumber: '',
    address: undefined,
  };
}

export const Basket_ContactDetails: MessageFns<Basket_ContactDetails> = {
  encode(
    message: Basket_ContactDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.firstName !== '') {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== '') {
      writer.uint32(18).string(message.lastName);
    }
    if (message.email !== '') {
      writer.uint32(26).string(message.email);
    }
    if (message.phoneNumber !== '') {
      writer.uint32(34).string(message.phoneNumber);
    }
    if (message.address !== undefined) {
      Basket_Address.encode(message.address, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Basket_ContactDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket_ContactDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = Basket_Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket_ContactDetails {
    return {
      firstName: isSet(object.firstName)
        ? globalThis.String(object.firstName)
        : '',
      lastName: isSet(object.lastName)
        ? globalThis.String(object.lastName)
        : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      phoneNumber: isSet(object.phoneNumber)
        ? globalThis.String(object.phoneNumber)
        : '',
      address: isSet(object.address)
        ? Basket_Address.fromJSON(object.address)
        : undefined,
    };
  },

  toJSON(message: Basket_ContactDetails): unknown {
    const obj: any = {};
    if (message.firstName !== '') {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== '') {
      obj.lastName = message.lastName;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.phoneNumber !== '') {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.address !== undefined) {
      obj.address = Basket_Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket_ContactDetails>, I>>(
    base?: I,
  ): Basket_ContactDetails {
    return Basket_ContactDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket_ContactDetails>, I>>(
    object: I,
  ): Basket_ContactDetails {
    const message = createBaseBasket_ContactDetails();
    message.firstName = object.firstName ?? '';
    message.lastName = object.lastName ?? '';
    message.email = object.email ?? '';
    message.phoneNumber = object.phoneNumber ?? '';
    message.address =
      object.address !== undefined && object.address !== null
        ? Basket_Address.fromPartial(object.address)
        : undefined;
    return message;
  },
};

function createBaseBasket_Address(): Basket_Address {
  return {
    addressLine1: '',
    addressLine2: '',
    postalCode: '',
    city: '',
    state: '',
    country: '',
  };
}

export const Basket_Address: MessageFns<Basket_Address> = {
  encode(
    message: Basket_Address,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.addressLine1 !== '') {
      writer.uint32(10).string(message.addressLine1);
    }
    if (message.addressLine2 !== '') {
      writer.uint32(18).string(message.addressLine2);
    }
    if (message.postalCode !== '') {
      writer.uint32(26).string(message.postalCode);
    }
    if (message.city !== '') {
      writer.uint32(34).string(message.city);
    }
    if (message.state !== '') {
      writer.uint32(42).string(message.state);
    }
    if (message.country !== '') {
      writer.uint32(50).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Basket_Address {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket_Address();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressLine1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressLine2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket_Address {
    return {
      addressLine1: isSet(object.addressLine1)
        ? globalThis.String(object.addressLine1)
        : '',
      addressLine2: isSet(object.addressLine2)
        ? globalThis.String(object.addressLine2)
        : '',
      postalCode: isSet(object.postalCode)
        ? globalThis.String(object.postalCode)
        : '',
      city: isSet(object.city) ? globalThis.String(object.city) : '',
      state: isSet(object.state) ? globalThis.String(object.state) : '',
      country: isSet(object.country) ? globalThis.String(object.country) : '',
    };
  },

  toJSON(message: Basket_Address): unknown {
    const obj: any = {};
    if (message.addressLine1 !== '') {
      obj.addressLine1 = message.addressLine1;
    }
    if (message.addressLine2 !== '') {
      obj.addressLine2 = message.addressLine2;
    }
    if (message.postalCode !== '') {
      obj.postalCode = message.postalCode;
    }
    if (message.city !== '') {
      obj.city = message.city;
    }
    if (message.state !== '') {
      obj.state = message.state;
    }
    if (message.country !== '') {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket_Address>, I>>(
    base?: I,
  ): Basket_Address {
    return Basket_Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket_Address>, I>>(
    object: I,
  ): Basket_Address {
    const message = createBaseBasket_Address();
    message.addressLine1 = object.addressLine1 ?? '';
    message.addressLine2 = object.addressLine2 ?? '';
    message.postalCode = object.postalCode ?? '';
    message.city = object.city ?? '';
    message.state = object.state ?? '';
    message.country = object.country ?? '';
    return message;
  },
};

function createBaseBasket_Item(): Basket_Item {
  return { itemId: '', name: '', description: '', quantity: 0, price: 0 };
}

export const Basket_Item: MessageFns<Basket_Item> = {
  encode(
    message: Basket_Item,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemId !== '') {
      writer.uint32(10).string(message.itemId);
    }
    if (message.name !== '') {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Basket_Item {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.price = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket_Item {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : '',
      name: isSet(object.name) ? globalThis.String(object.name) : '',
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : '',
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: Basket_Item): unknown {
    const obj: any = {};
    if (message.itemId !== '') {
      obj.itemId = message.itemId;
    }
    if (message.name !== '') {
      obj.name = message.name;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket_Item>, I>>(base?: I): Basket_Item {
    return Basket_Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket_Item>, I>>(
    object: I,
  ): Basket_Item {
    const message = createBaseBasket_Item();
    message.itemId = object.itemId ?? '';
    message.name = object.name ?? '';
    message.description = object.description ?? '';
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseBasket_PaymentDetails(): Basket_PaymentDetails {
  return {
    paymentMethod: '',
    transactionId: '',
    status: '',
    paymentDate: undefined,
  };
}

export const Basket_PaymentDetails: MessageFns<Basket_PaymentDetails> = {
  encode(
    message: Basket_PaymentDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentMethod !== '') {
      writer.uint32(10).string(message.paymentMethod);
    }
    if (message.transactionId !== '') {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.status !== '') {
      writer.uint32(26).string(message.status);
    }
    if (message.paymentDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.paymentDate),
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Basket_PaymentDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket_PaymentDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket_PaymentDetails {
    return {
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : '',
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : '',
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      paymentDate: isSet(object.paymentDate)
        ? fromJsonTimestamp(object.paymentDate)
        : undefined,
    };
  },

  toJSON(message: Basket_PaymentDetails): unknown {
    const obj: any = {};
    if (message.paymentMethod !== '') {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.transactionId !== '') {
      obj.transactionId = message.transactionId;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.paymentDate !== undefined) {
      obj.paymentDate = message.paymentDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket_PaymentDetails>, I>>(
    base?: I,
  ): Basket_PaymentDetails {
    return Basket_PaymentDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket_PaymentDetails>, I>>(
    object: I,
  ): Basket_PaymentDetails {
    const message = createBaseBasket_PaymentDetails();
    message.paymentMethod = object.paymentMethod ?? '';
    message.transactionId = object.transactionId ?? '';
    message.status = object.status ?? '';
    message.paymentDate = object.paymentDate ?? undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === 'string') {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
